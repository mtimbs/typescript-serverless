service:
  name: typescript-serverless

custom:
  webpack:
    webpackConfig: ./webpack.config.js
    includeModules: true
  serverless-iam-roles-per-function:
    defaultInherit: true # Each function will inherit the service level roles too.
  globalTables:
    regions: # list of regions in which you want to set up global tables
      - us-east-2 # Ohio (default region to date for stack)
      - ap-southeast-2 # Sydney (lower latency for Australia)
    createStack: true
  prune:
    automatic: true
    number: 3



plugins:
  - serverless-offline
  - serverless-webpack
  - serverless-iam-roles-per-function
  - serverless-create-global-dynamodb-table
  - serverless-prune-plugin

provider:
  name: aws
  runtime: nodejs12.x
  stage: ${opt:stage, 'local'}
  region: ${opt:region, 'us-east-2'}
  apiGateway:
    minimumCompressionSize: 1024 # Enable gzip compression for responses > 1 KB
  environment:
    DEBUG: '*'
    NODE_ENV: ${self:provider.stage}
    AWS_NODEJS_CONNECTION_REUSE_ENABLED: 1
  tracing:
    lambda: true
  iamRoleStatements:
    - Effect: Allow
      Action:
        - xray:PutTraceSegments
        - xray:PutTelemetryRecords
      Resource: "*"



resources:
  Resources:
    # Use Single Table design and index overloading  where possible. It's the most flexible and scales the best
    DynamoDBTable:
      Type: AWS::DynamoDB::Table
      DeletionPolicy: Retain
      Properties:
        TableName: ${self:service}-${self:provider.stage}
        BillingMode: PAY_PER_REQUEST
        StreamSpecification:
          StreamViewType: NEW_AND_OLD_IMAGES
        SSESpecification:
          SSEEnabled: true
        PointInTimeRecoverySpecification:
          PointInTimeRecoveryEnabled: true
        TimeToLiveSpecification:
          AttributeName: ttl
          Enabled: true
        KeySchema:
          - AttributeName: pk
            KeyType: HASH
          - AttributeName: sk
            KeyType: RANGE
        AttributeDefinitions:
          - AttributeName: pk
            AttributeType: S
          - AttributeName: sk
            AttributeType: S
          - AttributeName: gsi1pk
            AttributeType: S
          - AttributeName: gsi1sk
            AttributeType: S
          - AttributeName: gsi2pk
            AttributeType: S
          - AttributeName: gsi2sk
            AttributeType: S
        GlobalSecondaryIndexes:
          - IndexName: gsi1
            KeySchema:
              - AttributeName: gsi1pk
                KeyType: HASH
              - AttributeName: gsi1sk
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
          - IndexName: gsi2
            KeySchema:
              - AttributeName: gsi2pk
                KeyType: HASH
              - AttributeName: gsi2sk
                KeyType: RANGE
            Projection:
              ProjectionType: ALL

    ExampleQueue:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: ${self:service}-${self:provider.stage}-example-queue
        VisibilityTimeout: 180
        RedrivePolicy:
          deadLetterTargetArn: !GetAtt ExampleDLQ.Arn
          maxReceiveCount: 3

    ExampleDLQ:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: ${self:service}-${self:provider.stage}-example-dlq

    ExampeleSNSTopic:
      Type: AWS::SNS::Topic
      Properties:
        TopicName: ${self:service}-${self:provider.stage}-example-sns

    # Rather than triggering lambdas of SNS directly it is better to Push SNS into SQS and then process the Queue. This ensures messages don't get dropped if lambdas throttle
    # Here we create a policy to allow SNS to publish to the queue
    ExampleSNSTopicPublishingToExampleQueuePolicy:
      Type: AWS::SQS::QueuePolicy
      Properties:
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
            - Sid: 'allow-sns-message'
              Effect: Allow
              Principal: '*'
              Resource: !GetAtt ExampleQueue.Arn
              Action: 'sqs:SendMessage'
              Condition:
                ArnEquals:
                  'aws:SourceArn': !Ref ExampeleSNSTopic
        Queues:
          - Ref: ExampleQueue

  # And here we wire the topic into the Queue
  ExampleSNSTopicPublishingToExampleQueueSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      Protocol: sqs
      Endpoint: !GetAtt ExampleQueue.Arn
      TopicArn: !Ref ExampeleSNSTopic
      RawMessageDelivery: 'true'




functions:
  ApiGatewayProxyHandler:
    handler: src/handlers/apiGatewayHandler.proxyHandler
    events:
      - http:
          method: get
          path: proxy
    iamRoleStatements:
      # Example if you need to Query against a GSI. You need to explicitly giver permission to access the GSI.
      - Effect: Allow
        Action:
          - dynamodb:Query
        Resource:
          - !GetAtt DynamoDBTable.Arn
          - !Join [ '/', [ !GetAtt DynamoDBTable.Arn, index/gsi1 ] ]

  SQSHandler:
    handler: src/handlers/sqsHandler.handle
    description: Example handler for SQS event source
    timeout: 30
    memorySize: 512
    environment:
      FOO: BAR
    events:
      - sqs:
          arn: !GetAtt ExampleQueue.Arn
          batchSize: 10
    iamRoleStatements:
      - Effect: Allow
        Action: sqs:ReceiveMessage
        Resource: !GetAtt ExampleQueue.Arn

  DynamoDBStreamHandler:
    handler: src/handlers/dynamoDBStreamHandler.handle
    description: Example handler triggered by DynamoDB Streams
    timeout: 10
    memorySize: 512
    events:
      - stream:
          type: dynamodb
          arn: !GetAtt DynamoDBTable.StreamArn
          startingPosition: TRIM_HORIZON
          maximumRetryAttempts: 2
          batchSize: 20
          batchWindow: 3
    iamRoleStatements:
      - Effect: Allow
        Action:
          - dynamodb:Query
          - dynamodb:GetItem
        Resource: !GetAtt DynamoDBTable.Arn
    environment:
      DYNAMODB_TABLE: !Ref DynamoDBTable
